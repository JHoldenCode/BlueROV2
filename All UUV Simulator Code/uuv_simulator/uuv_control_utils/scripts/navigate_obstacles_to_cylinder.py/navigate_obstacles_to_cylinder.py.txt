#!/usr/bin/env python

import rospy
import message_filters
import math
from sensor_msgs.msg import Range
from geometry_msgs.msg import Twist
from uuv_control_msgs.msg import TrajectoryPoint

pub = rospy.Publisher('/rexrov2/cmd_vel', Twist, queue_size=10)
sonar_front = 0
sonar_left = 0
sonar_right = 0
pose_x = 0
pose_y = 0
goal_x = -10
goal_y = -200
curr_angle = 1.57
goal_angle = 0
avoiding = False

def sonar_callback(sonar0, sonar1, sonar3):
    global avoiding

    sonar_front = sonar0.range
    sonar_left = sonar1.range
    sonar_right = sonar3.range

    vel = Twist()
    rate = rospy.Rate(10)

    vel.linear.x = 0
    vel.angular.z = 0

    if pose_x > goal_x - 10 and pose_x < goal_x + 10 and pose_y > goal_y - 10 and pose_y < goal_y + 10:
        rospy.loginfo('done')
        vel.linear.x = 0
        vel.angular.z = 0
        pub.publish(vel)
    elif sonar_front > 10 and sonar_left > 10 and sonar_right > 10 and not (curr_angle > goal_angle - .2 and curr_angle < goal_angle + .2) and not avoiding:
        #turn toward goal
        rospy.loginfo('twist')
        degrees = (goal_angle - curr_angle) * 180 / math.pi
        vel.linear.x = 0
        for i in range(int(math.fabs(degrees) / 2)):
            if degrees > 0:
                vel.angular.z = .25
            else:
                vel.angular.z = -.25
            pub.publish(vel)
            rate.sleep()
    elif sonar_front < 10:
        #turn away (right)
        rospy.loginfo('avoid')
        avoiding = True
        vel.linear.x = 0
        vel.angular.z = -.25
        for i in range(5):
            pub.publish(vel)
            rate.sleep()
    elif avoiding:
        rospy.loginfo('avoiding')
        for i in range(60):
            vel.linear.x = 5
            vel.angular.z = 0
            pub.publish(vel)
            rate.sleep()
        avoiding = False
    else:
        #move
        rospy.loginfo('move')
        vel.angular.z = 0
        vel.linear.x = 5

    pub.publish(vel)




def pose_callback(pose):
    global goal_angle
    global curr_angle
    global pose_x
    global pose_y

    pose_x = pose.pose.position.x
    pose_y = pose.pose.position.y

    t3 = 2.0 * (pose.pose.orientation.w * pose.pose.orientation.z + pose.pose.orientation.x * pose.pose.orientation.y)
    t4 = 1.0 - 2.0 * (pose.pose.orientation.y * pose.pose.orientation.y + pose.pose.orientation.z * pose.pose.orientation.z)
    curr_angle = math.atan2(t3, t4)

    x_dist = goal_x - pose_x
    y_dist = goal_y - pose_y

    if x_dist < 1 and x_dist > -1:
        if y_dist > 1:
            goal_angle = 1.57
        elif y_dist < 1:
            goal_angle = -1.57
    elif y_dist < 1 and y_dist > -1:
        if x_dist > 1:
            goal_angle = 0
        elif x_dist < 1:
            goal_angle = 3.14
    elif x_dist >= 0 and y_dist >= 0:
        goal_angle = math.atan(y_dist / x_dist)
    elif x_dist < 0 and y_dist >= 0:
        goal_angle = 3.14 - math.atan(y_dist / (-x_dist))
    elif x_dist < 0 and y_dist < 0:
        goal_angle = -1 * (3.14 - math.atan((-y_dist) / (-x_dist)))
    else:
        goal_angle = -1 * math.atan((-y_dist) / x_dist)
    #rospy.loginfo(x_dist)
    #rospy.loginfo(y_dist)
    #rospy.loginfo(goal_angle)





def go():
    rospy.init_node('avoid', anonymous=True)

    rospy.Subscriber('/rexrov2/dp_controller/reference', TrajectoryPoint, pose_callback)

    sonar0_sub = message_filters.Subscriber('/rexrov2/dvl_sonar0', Range)
    sonar1_sub = message_filters.Subscriber('/rexrov2/dvl_sonar1', Range)
    sonar3_sub = message_filters.Subscriber('/rexrov2/dvl_sonar3', Range)

    ts = message_filters.TimeSynchronizer([sonar0_sub, sonar1_sub, sonar3_sub], 10)
    ts.registerCallback(sonar_callback)


    rospy.spin()




if __name__ == '__main__':
    try:
        go()
    except rospy.ROSInterruptException:
        pass